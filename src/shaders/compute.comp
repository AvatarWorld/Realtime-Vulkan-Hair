#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WORKGROUP_SIZE 32
#define NUM_CURVE_POINTS 10
#define EPSILON 0.00001
#define DAMPING 0.9992
#define NUM_COLLIDERS 2
layout(local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform CameraBufferObject {
    mat4 view;
    mat4 proj;
} camera;

layout(set = 1, binding = 0) uniform Time {
    float deltaTime;
    float totalTime;
};

struct Collider {
	vec3 center;
	float radius;
};

// TODO: pass number of colliders?
layout(set = 2, binding = 0) uniform Colliders {
	Collider colliders[];
};

struct Strand {
    vec4 curvePoints[NUM_CURVE_POINTS];
	vec4 curveVels[NUM_CURVE_POINTS];
	vec4 correctionVecs[NUM_CURVE_POINTS];
};

layout(set = 3, binding = 0) buffer InStrands {
	Strand inStrands[];
};

// The project is using vkCmdDrawIndirect to use a buffer as the arguments for a draw call
// This is sort of an advanced feature so we've showed you what this buffer should look like
layout(set = 3, binding = 1) buffer NumStrands {
 	  uint vertexCount;   // Write the number of blades remaining here
 	  uint instanceCount; // = 1
 	  uint firstVertex;   // = 0
	  uint firstInstance; // = 0
} numStrands;

void main() {
	// Reset the number of blades to 0
	uint threadIdx = gl_GlobalInvocationID.x;
	if (threadIdx == 0) {
		numStrands.vertexCount = 0;
	}
	barrier(); // Wait till all threads reach this point

	vec3 gravityDir = vec3(0.f, -1.f, 0.f);
	float gravityAcc = 9.81f;
	vec3 gravity = gravityDir * gravityAcc;
	
	Strand strand = inStrands[threadIdx];
	
	// Temporarily hard codes radius between curve points
	float radius = 4.0 / (NUM_CURVE_POINTS - 1.0);
//	float radius = strand.len / (NUM_CURVE_POINTS - 1.0);

	// Temporarily controls motion of root curve points
	strand.curveVels[0] = vec4(3.0 * sin(totalTime), 0.0, 0.5 * sin(totalTime), 0.0);
	strand.curvePoints[0] += deltaTime * strand.curveVels[0];

	// Temporarily hard codes collision object
	Collider c1 = colliders[1];
	vec3 sphereCenter = c1.center;
	float sphereRadius = c1.radius + 0.08;

	float extraDamp = 1.0; // additional damping to track if a parent curve point hit a collision object

	for (int i = 1; i < NUM_CURVE_POINTS; i++) {
		vec3 currentPos = strand.curvePoints[i].xyz;
		vec3 currentVel = strand.curveVels[i].xyz;
		vec3 parentPos = strand.curvePoints[i - 1].xyz;
		
		float distToSphereCenter = distance(currentPos.xyz, sphereCenter);

		// Add gravity
		vec3 force = vec3(0.0, -9.8, 0.0);

		// Add penalty force to push hair outside of collision object
		if (distToSphereCenter < sphereRadius) {
			float k = 1800.0; // spring constant, as large as possible without exploding
			float d = abs(sphereRadius - distToSphereCenter); // depth of curve point inside the collision object
			vec3 normal = normalize(currentPos.xyz - sphereCenter); // normal of collision surface at point of collision
			force += vec3(k * d * normal); // penalty spring force
			extraDamp = max(1.0 - 0.8 * d, 0.9994); // add extra damping proprotional to depth
		} 

		// Get predicted position based on position, velocity, and force
		vec3 predictedPos = currentPos + deltaTime * currentVel + deltaTime * deltaTime * force;
		vec3 newPos = predictedPos;

		// Apply follow the leader constraint
		vec3 direction = normalize(predictedPos - parentPos);
		newPos = parentPos + radius * direction;

		// Update buffers and correction vectors
		vec3 newVel = (newPos - currentPos) / deltaTime;
		strand.curvePoints[i] = vec4(newPos, 1.0);
		strand.curveVels[i] = vec4(DAMPING * extraDamp * newVel, 0.0); 
		strand.correctionVecs[i] = vec4(extraDamp * (newPos - predictedPos), 0.0);
	}

	// Apply velocity correction term
	for (int i = 1; i < NUM_CURVE_POINTS - 1; ++i) {
		strand.curveVels[i] -= vec4(DAMPING * strand.correctionVecs[i + 1].xyz / deltaTime, 0.0);
	}

	inStrands[threadIdx] = strand;

	atomicAdd(numStrands.vertexCount, 1);
}
