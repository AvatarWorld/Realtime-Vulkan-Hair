#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WORKGROUP_SIZE 32
#define NUM_CURVE_POINTS 10
#define EPSILON 0.00001
#define DAMPING 0.9994

layout(local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform CameraBufferObject {
    mat4 view;
    mat4 proj;
} camera;

layout(set = 1, binding = 0) uniform Time {
    float deltaTime;
    float totalTime;
};

struct Strand {
    vec4 curvePoints[NUM_CURVE_POINTS];
	vec4 curveVels[NUM_CURVE_POINTS];
	vec4 correctionVecs[NUM_CURVE_POINTS];
//	float len;
};

layout(set = 2, binding = 0) buffer InStrands {
	Strand inStrands[];
};

// The project is using vkCmdDrawIndirect to use a buffer as the arguments for a draw call
// This is sort of an advanced feature so we've showed you what this buffer should look like
layout(set = 2, binding = 1) buffer NumStrands {
 	  uint vertexCount;   // Write the number of blades remaining here
 	  uint instanceCount; // = 1
 	  uint firstVertex;   // = 0
	  uint firstInstance; // = 0
} numStrands;


void main() {
	// Reset the number of blades to 0
	uint threadIdx = gl_GlobalInvocationID.x;
	if (threadIdx == 0) {
		numStrands.vertexCount = 0;
	}
	barrier(); // Wait till all threads reach this point

	vec3 gravityDir = vec3(0.f, -1.f, 0.f);
	float gravityAcc = 9.81f;
	vec3 gravity = gravityDir * gravityAcc;
	
	Strand strand = inStrands[threadIdx];
	float radius = 4.0 / (NUM_CURVE_POINTS - 1.0);
//	float radius = strand.len / (NUM_CURVE_POINTS - 1.0);

	strand.curveVels[0] = vec4(3.0 * sin(totalTime), 0.0, 0.0, 0.0);
	strand.curvePoints[0] += deltaTime * strand.curveVels[0];

	vec3 sphereCenter = vec3(2.0, -0.5, 1.0);
	float sphereRadius = 2.0;


	for (int i = 1; i < NUM_CURVE_POINTS; i++) {
		vec4 currentPos = strand.curvePoints[i];
		vec4 currentVel = strand.curveVels[i];
		vec4 parentPos = strand.curvePoints[i - 1];


		float distToSphereCenter = distance(currentPos.xyz, sphereCenter);

		vec4 force = vec4(0.0, -9.8, 0.0, 0.0);
		if (distToSphereCenter < sphereRadius) {
			float k = 500.0;
			float d = abs(sphereRadius - distToSphereCenter);
			vec3 normal = normalize(currentPos.xyz - sphereCenter);
			force += vec4(k * d * normal, 0.0);
		}
		vec4 predictedPos = currentPos + deltaTime * currentVel + deltaTime * deltaTime * force;
		
		vec4 newPos = predictedPos;

		vec4 direction = normalize(predictedPos - parentPos);
		newPos = parentPos + radius * direction;

		vec4 newVel = (newPos - currentPos) / deltaTime;
		strand.curvePoints[i] = newPos;
		strand.curveVels[i] = DAMPING * newVel;
		strand.correctionVecs[i] = newPos - predictedPos;
	}





//	for (int i = 1; i < NUM_CURVE_POINTS; i++) {
//		vec4 currentPos = strand.curvePoints[i];
//		vec4 currentVel = strand.curveVels[i];
//		vec4 parentPos = strand.curvePoints[i - 1];
//
//		vec4 force = vec4(0.0, -9.8, 0.0, 0.0);
//		vec4 predictedPos = currentPos + deltaTime * currentVel + deltaTime * deltaTime * force;
//		
//		vec4 newPos = predictedPos;
//		vec4 direction = normalize(predictedPos - parentPos);
//		newPos = parentPos + radius * direction;
//		strand.curvePoints[i] = newPos;
//		strand.correctionVecs[i] = currentPos;
//	}

//	for (int i = 1; i < NUM_CURVE_POINTS; i++) {
//		vec4 currentPos = strand.correctionVecs[i];
//		vec4 currentVel = strand.curveVels[i];
//		vec4 parentPos = strand.curvePoints[i - 1];
//
//		vec4 force = vec4(0.0, -9.8, 0.0, 0.0);
//		vec4 predictedPos = currentPos + deltaTime * currentVel + deltaTime * deltaTime * force;
//		
//		vec4 newPos = strand.curvePoints[i];
////		vec4 direction = normalize(predictedPos - parentPos);
////		newPos = parentPos + radius * direction;
//
//		float currPosDistToSphereCenter = distance(currentPos.xyz, sphereCenter);
//		float predPosDistToSphereCenter = distance(newPos.xyz, sphereCenter);
//
//		if (predPosDistToSphereCenter < sphereRadius) {
//			if (currPosDistToSphereCenter < sphereRadius) {
//				vec3 normal = normalize(newPos.xyz - sphereCenter);
//				vec3 q = sphereCenter + normal * sphereRadius;
//
////				for (int iter = 0; iter < 3; ++iter) {
//					float C = dot(newPos.xyz - q, normal);
//					newPos += vec4(-C * normal, 0.0);
//
////					vec4 dirFromParent = normalize(newPos - parentPos);
////					newPos = parentPos + radius * dirFromParent;
////				}
//			} else {
//				vec3 dir = normalize(newPos.xyz - currentPos.xyz);
//				float innerSqrt = pow(2 * (dot(dir, currentPos.xyz - sphereCenter)), 2) - 4 * length(dir) * length(dir) * (pow(length(currentPos.xyz - sphereCenter), 2) - sphereRadius * sphereRadius);\
//				if (innerSqrt >= 0) {
//					float t = (-2 * (dot(dir, currentPos.xyz - sphereCenter)) - sqrt(innerSqrt)) / (2 * length(dir) * length(dir));
//
//
//					vec3 q = currentPos.xyz + t * dir;
//					vec3 normal = normalize(q - sphereCenter);
//
////				for (int iter = 0; iter < 3; ++iter) {
//					float C = dot(newPos.xyz - q, normal);
////					newPos += vec4(-C * normal, 0.0);
//
////					vec4 dirFromParent = normalize(newPos - parentPos);
////					newPos = parentPos + radius * dirFromParent;
////				}
//				}
//			}
//		} else {
////			vec4 direction = normalize(predictedPos - parentPos);
////			newPos = parentPos + radius * direction;
//		}
//
//		vec4 newVel = (newPos - currentPos) / deltaTime;
//		strand.curvePoints[i] = newPos;
//		strand.curveVels[i] = DAMPING * newVel;
//		strand.correctionVecs[i] = newPos - predictedPos;
//		
//	}
	for (int i = 1; i < NUM_CURVE_POINTS - 1; ++i) {
		strand.curveVels[i] -= DAMPING * strand.correctionVecs[i + 1] / deltaTime;
	}

	inStrands[threadIdx] = strand;

	atomicAdd(numStrands.vertexCount, 1);
}
